1 Algoritmos de Búsqueda y Ordenamiento Programación de Computadores IWI-131-p1 Prof.: Teddy Alfaro Olave Departamento de Informática Universidad Técnica Federico Santa María Algoritmos de Búsqueda Los procesos de búsqueda involucran recorrer un arreglo completo con el fin de encontrar algo. Lo más común es buscar el menor o mayor elemento (cuando es puede establecer un orden), o buscar el índice de un elemento determinado. Para buscar el menor o mayor elemento de un arreglo, podemos usar la estrategia, de suponer que el primero o el último es el menor (mayor), para luego ir comparando con cada uno de los elementos , e ir actualizando el menor (mayor). A esto se le llama Búsqueda Lineal.
2 Algoritmos de Búsqueda Definición: Para encontrar un dato dentro de un arreglo, para ello existen diversos algoritmos que varían en complejidad, eficiencia, tamaño del dominio de búsqueda. Algoritmos de Búsqueda: Búsqueda Secuencial Búsqueda Binaria Búsqueda Secuencial Consiste en ir comparando el elemento que se busca con cada elemento del arreglo hasta cuando se encuentra. Busquemos el elementos u C omputacionuuuuu0123456789 10 Resultado = 43Búsqueda Secuencial Búsqueda del menor menor = a[0]; for (i=1;i<n;i++) if ( a[i]<menor ) menor=a[i]; Búsqueda del mayor mayor= a[n-1]; for (i=0;i<n-1;i++) if( a[i]>mayor ) mayor=a[i]; Búsqueda de elemento encontrado=-1; for (i=0;i<n;i++) if( a[i]==elemento_buscado ) encontrado=i; Ejemplo Desarrollar un programa que posea una función que reciba como parámetro un arreglo de 10 enteros, y un entero, y retorne la posición del entero si es que se encuentra, de lo contrario devolver 1. #include<stdio.h> intencuentra(intA[], intb) { intk=1, result=-1; do{ if(A[k]== b) result=k; else k++; }while((result==-1)&&(k<10)); return result; } int main() { inti, x[10]; for(i=0;i<10;i++) scanf("%d",&x[i]); i = encuentra( x, 10); printf("resultado %d\n",i); return0; }
4 Eficiencia y Complejidad Considerando la Cantidad de Comparaciones Mejor Caso: El elemento buscado está en la primera posición. Es decir, se hace una sola comparación Peor Caso: El elemento buscado está en la última posición. Necesitando igual cantidad de comparaciones que de elementos el arreglo En Promedio: El elemento buscado estará cerca de la mitad. Necesitando en promedio, la mitad de comparaciones que de elementos Por lo tanto, la velocidad de ejecución depende linealmente del tamaño del arreglo 1nn/2Búsqueda Binaria En el caso anterior de búsqueda se asume que los elementos están en cualquier orden. En el peor de los casos deben hacerse n operaciones de comparación. Una búsqueda más eficiente puede hacerse sobre un arreglo ordenado. Una de éstas es la Búsqueda Binaria. La Búsqueda Binaria, compara si el valor buscado está en la mitad superior o inferior. En la que esté, subdivido nuevamente, y así sucesivamente hasta encontrar el valor.
5 17 13 19 8Búsqueda Binaria Supuesto: Arreglo con datos ordenados en forma ascendente: i<k  a[i]<a[k] Estamos buscando la posición del valor 17 23456102356 13 17 19 23 6789 10 25 (0+11)/2= 5234568213456 13 17 23 789 10 0 25 (6+11)/2= 8 26 11 11 26 234568102345 17 19 23 6789 10 25 11 26 (6+7)/2= 68 17 <=8 17 >=8 + 19 17 <=19 17 >=19 - 234568102345 13 19 23 6789 10 25 11 26 (7+7)/2= 7 13 17 <=13 17 >=13 + 17 17 <=17 17 >=17 + - L>U Algoritmo de Búsqueda Binaria #include<stdio.h> int main() { intb,i,j,k, v[12]; for(i=0;i<12;i++) scanf("%d",&v[i]); printf("fin del llenado\n"); printf("ingrese numero a buscar "); scanf("%d",&b); i= 0; j= 12-1; do { k= (i+j)/2; if (v[k]<=b ) i=k+1; if (v[k]>=b ) j= k-1; } while (i<=j); printf("elemento %d esta en%d\n",v[k],k); return0; } i= 0; j= tamaño-1; do { k= (i+j)/2; if (v[k]<=b ) i=k+1; if (v[k]>=b ) j= k-1; } while(i<=j);
6 Algoritmo de Búsqueda Binaria #include<stdio.h> int main() { intb,i,j,k, v[12]; for(i=0;i<12;i++) s canf("%d",&v[i]); printf("fin del llenado\n"); p rintf("ingrese numero a buscar "); scanf("%d",&b); i = 0; j= 12-1; do { k= (i+j)/2; if (v[k]<=b ) i=k+1; if (v[k]>=b ) j = k-1; } while (i<=j); p rintf("elemento %d esta en%d\n",v[k],k); return0; } i= 0; j= tamaño-1; do { k= (i+j)/2; if (v[k]<=b ) i=k+1; if (v[k]>=b ) j= k-1; } while(i<=j); Complejidad y Eficiencia Contando Comparaciones Mejor Caso: El elemento buscado está en el centro. Por lo tanto, se hace una sola comparación Peor Caso: El elemento buscado está en una esquina. Necesitando log 2 (n) cantidad de comparaciones En Promedio: Serán algo como log 2 (n/2) Por lo tanto, la velocidad de ejecución depende logarítmicamente deltamaño del arreglo 1 log(n) log(n/2)
7 Ordenamiento de Componentes Ordenamiento Ascendente Existen numerosos algoritmos para ordenar. A continuación se verán algunos algoritmos de ordenamiento. Ordenamiento Burbuja (bublesort): Idea: vamos comparando elementos adyacentes y empujamos los valores más livianos hacia arriba (los más pesados van quedando abajo). Idea de la burbuja que asciende, por lo liviana que es. 368452102345 Ordenamiento Burbuja 6384523684523684523684523684523648523648523645823645823645283645283645283645283465283465283456283456283452681023451023458 Ordenamiento Burbuja 345268345268345268345268345268342568342568342568342568324568324568234568234568102345102345102345 Algoritmo Ordenamiento Burbuja #include <stdio.h> #define N6 void intercambia(int *f,int*g) { int tmp; tmp= *f; *f = *g; *g = tmp; } int main() { int i,j, v[N]={3,4,5,2,6,8}; for (i=N-1;i>1;i--) for (j=0;j<i;j++) if (v[j]>v[j+1]) intercambia(&v[j],&v[j+1]); for (i=0;i<N;i++) printf("%d\n",v[i]); return0; } for (i=N-1;i>0;i--) for (j=0;j<i;j++) if (V[j]>V[j+1]) Intercambia(&A[j],&A[j+1]);
9 Complejidad y Eficiencia Cantidad de Comparaciones: Constante: n*(n+1)/2 Cantidad de Intercambios: Mejor Caso: Arreglo ordenado. Por lo tanto, no se hace ni un solo swap Peor Caso: Arreglo ordenado inversamente. Se necesitaránn*(n+1)/2 cantidad de swaps En Promedio: Serán algo como n*(n+1)/4 swaps Por lo tanto, la velocidad de ejecución depende cuadráticamentedel tamaño del arreglo 0n*(n+1)/2n*(n+1)/4Búsqueda en Arreglos Bidimensionales
10 Arreglos Bidimensionales. Definición : Es un arreglode dos dimensionesel cualestá indexado por medio de 2 índices. A[i][j] Declaración: tipo nombre_de_variable[tamaño_1][tamaño_2]; Una matriz bidimensional tiene la siguiente forma: Para acceder al dato a ij se hace de la siguiente manera: c=A[i][j]; mxn mn mmnnaaaaaaaaaA               = . . ......... ....... . ......... . ......... . . ......... ......... 212222111211 Arreglos Bidimensionales
11 Búsqueda Para buscar un elemento en un arreglo de dos dimensiones (el menor o el mayor), podemos suponer que uno de ellos es el menor (mayor), o mejor suponer un valor muy alto (o muy bajo), para luego contrastarlo uno a uno cada elemento, es decir una búsqueda secuencial. Ejemplo de Búsqueda #include <stdio.h> #define N3 int main() { int i,j,max,min, a[N][N]; for(i=0; i<N; i++) for(j=0; j<N; j++) a[i][j] = rand(); max=-1000; min= 1000; for(i=0;i<N;i++) for(j=0;j<N;j++) { if (a[i][j]>max) max = a[i][j]; if (a[i][j]<min) min = a[i][j]; } printf("el maximo es %dy el minimo es %d\n",max,min); return0; }
12 Búsqueda por Filas Algoritmo: Búsqueda por filas Algoritmo: Búsqueda por columnas tipo A[filas][columnas] for (i=0;i<filas;i++) for (j=0;j<columnas;j++) if (A[i][j]==elemento) printf(\nElemento encontrado!!!); tipo A[filas][columnas] for (j=0;j<columnas;j++) for (i=0;i<filas;i++) if (A[i][j]==elemento) printf(\nElemento encontrado!!!); Ejercicio 1 El gerente de las salas de cine Cinemax desea conocer algunas estadísticas respecto de las películas más vistas. Las mismas 15 películas son exhibidas en cada una de las 7 salas de cine. Para cada sala se requiere almacenar el total de personas que han asistido a ver cada película. Se requiere saber cual es la mejor combinación sala-película, más vista Cual fue la película más vista.
13 Ejercicio 2 La gerencia de la empresa Machucambo, preocupada por las bajas remuneraciones de su personal, ha decidido entregar una bonificación ascendiente al 5% del sueldo a los 25 empleados con más baja remuneración. El gerente desea tener una lista con el RUT de los beneficiados y, además, desea saber a cuánto asciende el costo total de las bonificaciones. La empresa almacenará los datos del personal en dos arreglos paralelos: uno contendrá el RUT de los 121 empleados y otro estará en correspondencia con éste conteniendo el sueldo de cada uno. Los arreglos son: #define N 121 int rut[n]; float sueldo[n]; ArreglosBidimensionales Ejercicios: 10.- Los conductores de un vehículo quellegan a un servicentro necesitan saber la distancia que recorreran desdeunaciudad a otra, paraasí saber cuánto combustible necesitarán. La distanciaentrelas ciuidades vienedada en una matriz con la siguientedefinición: int dist[N][N] ; en dondelos índices representan ciudades y dist[i][j] representa la distancia en [Km] entre la ciudad iy la j. La rutade ciudades quetienequeseguirun determinado conductor vienealmacenadaen un arreglo definido como: int ruta[M]; Calcular la cantidad de combustible necesitado.